### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type CrossTabRecordInfo {
  primaryId: String
  records: [Record]
  secondaryId: String
}

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type Element {
  details: Json
  id: String!
  isAnswer: Boolean!
  isChoice: Boolean!
  label: String
  question: Question
  records(after: RecordWhereUniqueInput, before: RecordWhereUniqueInput, first: Int, last: Int): [Record!]!
  time: DateTime!
  value: Int!
}

input ElementCreateembeddingInput {
  set: [Float!]
}

input ElementCreateInput {
  details: Json
  embedding: ElementCreateembeddingInput
  id: String
  isAnswer: Boolean
  isChoice: Boolean
  issue: IssueCreateOneWithoutElementsInput
  isTextAllowed: Boolean
  label: String
  question: QuestionCreateOneWithoutElementsInput
  records: RecordCreateManyWithoutElementsInput
  time: DateTime
  value: Int!
}

input ElementCreateManyWithoutQuestionInput {
  connect: [ElementWhereUniqueInput!]
  connectOrCreate: [ElementCreateOrConnectWithoutquestionInput!]
  create: [ElementCreateWithoutQuestionInput!]
}

input ElementCreateManyWithoutRecordsInput {
  connect: [ElementWhereUniqueInput!]
  connectOrCreate: [ElementCreateOrConnectWithoutrecordsInput!]
  create: [ElementCreateWithoutRecordsInput!]
}

input ElementCreateOrConnectWithoutquestionInput {
  create: ElementCreateWithoutQuestionInput!
  where: ElementWhereUniqueInput!
}

input ElementCreateOrConnectWithoutrecordsInput {
  create: ElementCreateWithoutRecordsInput!
  where: ElementWhereUniqueInput!
}

input ElementCreateWithoutQuestionInput {
  details: Json
  embedding: ElementCreateembeddingInput
  id: String
  isAnswer: Boolean
  isChoice: Boolean
  issue: IssueCreateOneWithoutElementsInput
  isTextAllowed: Boolean
  label: String
  records: RecordCreateManyWithoutElementsInput
  time: DateTime
  value: Int!
}

input ElementCreateWithoutRecordsInput {
  details: Json
  embedding: ElementCreateembeddingInput
  id: String
  isAnswer: Boolean
  isChoice: Boolean
  issue: IssueCreateOneWithoutElementsInput
  isTextAllowed: Boolean
  label: String
  question: QuestionCreateOneWithoutElementsInput
  time: DateTime
  value: Int!
}

input ElementListRelationFilter {
  every: ElementWhereInput
  none: ElementWhereInput
  some: ElementWhereInput
}

input ElementScalarWhereInput {
  AND: [ElementScalarWhereInput!]
  details: JsonNullableFilter
  embedding: FloatNullableListFilter
  id: StringFilter
  isAnswer: BoolFilter
  isChoice: BoolFilter
  issueId: StringNullableFilter
  isTextAllowed: BoolFilter
  label: StringNullableFilter
  NOT: [ElementScalarWhereInput!]
  OR: [ElementScalarWhereInput!]
  questionId: StringNullableFilter
  time: DateTimeFilter
  value: IntFilter
}

input ElementUpdateembeddingInput {
  set: [Float!]
}

input ElementUpdateInput {
  details: Json
  embedding: ElementUpdateembeddingInput
  id: StringFieldUpdateOperationsInput
  isAnswer: BoolFieldUpdateOperationsInput
  isChoice: BoolFieldUpdateOperationsInput
  issue: IssueUpdateOneWithoutElementsInput
  isTextAllowed: BoolFieldUpdateOperationsInput
  label: NullableStringFieldUpdateOperationsInput
  question: QuestionUpdateOneWithoutElementsInput
  records: RecordUpdateManyWithoutElementsInput
  time: DateTimeFieldUpdateOperationsInput
  value: IntFieldUpdateOperationsInput
}

input ElementUpdateManyMutationInput {
  details: Json
  embedding: ElementUpdateembeddingInput
  id: StringFieldUpdateOperationsInput
  isAnswer: BoolFieldUpdateOperationsInput
  isChoice: BoolFieldUpdateOperationsInput
  isTextAllowed: BoolFieldUpdateOperationsInput
  label: NullableStringFieldUpdateOperationsInput
  time: DateTimeFieldUpdateOperationsInput
  value: IntFieldUpdateOperationsInput
}

input ElementUpdateManyWithoutQuestionInput {
  connect: [ElementWhereUniqueInput!]
  connectOrCreate: [ElementCreateOrConnectWithoutquestionInput!]
  create: [ElementCreateWithoutQuestionInput!]
  delete: [ElementWhereUniqueInput!]
  deleteMany: [ElementScalarWhereInput!]
  disconnect: [ElementWhereUniqueInput!]
  set: [ElementWhereUniqueInput!]
  update: [ElementUpdateWithWhereUniqueWithoutQuestionInput!]
  updateMany: [ElementUpdateManyWithWhereWithoutQuestionInput!]
  upsert: [ElementUpsertWithWhereUniqueWithoutQuestionInput!]
}

input ElementUpdateManyWithoutRecordsInput {
  connect: [ElementWhereUniqueInput!]
  connectOrCreate: [ElementCreateOrConnectWithoutrecordsInput!]
  create: [ElementCreateWithoutRecordsInput!]
  delete: [ElementWhereUniqueInput!]
  deleteMany: [ElementScalarWhereInput!]
  disconnect: [ElementWhereUniqueInput!]
  set: [ElementWhereUniqueInput!]
  update: [ElementUpdateWithWhereUniqueWithoutRecordsInput!]
  updateMany: [ElementUpdateManyWithWhereWithoutRecordsInput!]
  upsert: [ElementUpsertWithWhereUniqueWithoutRecordsInput!]
}

input ElementUpdateManyWithWhereWithoutQuestionInput {
  data: ElementUpdateManyMutationInput!
  where: ElementScalarWhereInput!
}

input ElementUpdateManyWithWhereWithoutRecordsInput {
  data: ElementUpdateManyMutationInput!
  where: ElementScalarWhereInput!
}

input ElementUpdateWithoutQuestionInput {
  details: Json
  embedding: ElementUpdateembeddingInput
  id: StringFieldUpdateOperationsInput
  isAnswer: BoolFieldUpdateOperationsInput
  isChoice: BoolFieldUpdateOperationsInput
  issue: IssueUpdateOneWithoutElementsInput
  isTextAllowed: BoolFieldUpdateOperationsInput
  label: NullableStringFieldUpdateOperationsInput
  records: RecordUpdateManyWithoutElementsInput
  time: DateTimeFieldUpdateOperationsInput
  value: IntFieldUpdateOperationsInput
}

input ElementUpdateWithoutRecordsInput {
  details: Json
  embedding: ElementUpdateembeddingInput
  id: StringFieldUpdateOperationsInput
  isAnswer: BoolFieldUpdateOperationsInput
  isChoice: BoolFieldUpdateOperationsInput
  issue: IssueUpdateOneWithoutElementsInput
  isTextAllowed: BoolFieldUpdateOperationsInput
  label: NullableStringFieldUpdateOperationsInput
  question: QuestionUpdateOneWithoutElementsInput
  time: DateTimeFieldUpdateOperationsInput
  value: IntFieldUpdateOperationsInput
}

input ElementUpdateWithWhereUniqueWithoutQuestionInput {
  data: ElementUpdateWithoutQuestionInput!
  where: ElementWhereUniqueInput!
}

input ElementUpdateWithWhereUniqueWithoutRecordsInput {
  data: ElementUpdateWithoutRecordsInput!
  where: ElementWhereUniqueInput!
}

input ElementUpsertWithWhereUniqueWithoutQuestionInput {
  create: ElementCreateWithoutQuestionInput!
  update: ElementUpdateWithoutQuestionInput!
  where: ElementWhereUniqueInput!
}

input ElementUpsertWithWhereUniqueWithoutRecordsInput {
  create: ElementCreateWithoutRecordsInput!
  update: ElementUpdateWithoutRecordsInput!
  where: ElementWhereUniqueInput!
}

input ElementWhereInput {
  AND: [ElementWhereInput!]
  details: JsonNullableFilter
  embedding: FloatNullableListFilter
  id: StringFilter
  isAnswer: BoolFilter
  isChoice: BoolFilter
  issue: IssueWhereInput
  issueId: StringNullableFilter
  isTextAllowed: BoolFilter
  label: StringNullableFilter
  NOT: [ElementWhereInput!]
  OR: [ElementWhereInput!]
  question: QuestionWhereInput
  questionId: StringNullableFilter
  records: RecordListRelationFilter
  time: DateTimeFilter
  value: IntFilter
}

input ElementWhereUniqueInput {
  id: String
}

input FloatNullableListFilter {
  equals: [Float!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableListFilter {
  equals: [Int!]
}

input IssueCreateOneWithoutElementsInput {
  connect: IssueWhereUniqueInput
  connectOrCreate: IssueCreateOrConnectWithoutelementsInput
  create: IssueCreateWithoutElementsInput
}

input IssueCreateOrConnectWithoutelementsInput {
  create: IssueCreateWithoutElementsInput!
  where: IssueWhereUniqueInput!
}

input IssueCreatereferenceNumberInput {
  set: [Int!]
}

input IssueCreateWithoutElementsInput {
  id: String
  name: String!
  referenceNumber: IssueCreatereferenceNumberInput
  text: String!
}

input IssueUpdateOneWithoutElementsInput {
  connect: IssueWhereUniqueInput
  connectOrCreate: IssueCreateOrConnectWithoutelementsInput
  create: IssueCreateWithoutElementsInput
  delete: Boolean
  disconnect: Boolean
  update: IssueUpdateWithoutElementsInput
  upsert: IssueUpsertWithoutElementsInput
}

input IssueUpdatereferenceNumberInput {
  set: [Int!]
}

input IssueUpdateWithoutElementsInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  referenceNumber: IssueUpdatereferenceNumberInput
  text: StringFieldUpdateOperationsInput
}

input IssueUpsertWithoutElementsInput {
  create: IssueCreateWithoutElementsInput!
  update: IssueUpdateWithoutElementsInput!
}

input IssueWhereInput {
  AND: [IssueWhereInput!]
  elements: ElementListRelationFilter
  id: StringFilter
  name: StringFilter
  NOT: [IssueWhereInput!]
  OR: [IssueWhereInput!]
  referenceNumber: IntNullableListFilter
  text: StringFilter
}

input IssueWhereUniqueInput {
  id: String
}

scalar Json

input JsonNullableFilter {
  equals: Json
  not: Json
}

type Mutation {
  createOneElement(data: ElementCreateInput!): Element!
  createOneQuestion(data: QuestionCreateInput!): Question!
  createOneRecord(data: RecordCreateInput!): Record!
  createOneSection(data: SectionCreateInput!): Section!
  createOneSurvey(data: SurveyCreateInput!): Survey!
  createOneUser(data: UserCreateInput!): User!
  deleteManyElement(where: ElementWhereInput): BatchPayload!
  deleteManyQuestion(where: QuestionWhereInput): BatchPayload!
  deleteManyRecord(where: RecordWhereInput): BatchPayload!
  deleteManySection(where: SectionWhereInput): BatchPayload!
  deleteManySurvey(where: SurveyWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneElement(where: ElementWhereUniqueInput!): Element
  deleteOneQuestion(where: QuestionWhereUniqueInput!): Question
  deleteOneRecord(where: RecordWhereUniqueInput!): Record
  deleteOneSection(where: SectionWhereUniqueInput!): Section
  deleteOneSurvey(where: SurveyWhereUniqueInput!): Survey
  updateManyElement(data: ElementUpdateManyMutationInput!, where: ElementWhereInput): BatchPayload!
  updateManyQuestion(data: QuestionUpdateManyMutationInput!, where: QuestionWhereInput): BatchPayload!
  updateManyRecord(data: RecordUpdateManyMutationInput!, where: RecordWhereInput): BatchPayload!
  updateManySection(data: SectionUpdateManyMutationInput!, where: SectionWhereInput): BatchPayload!
  updateManySurvey(data: SurveyUpdateManyMutationInput!, where: SurveyWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOneElement(data: ElementUpdateInput!, where: ElementWhereUniqueInput!): Element
  updateOneQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question
  updateOneRecord(data: RecordUpdateInput!, where: RecordWhereUniqueInput!): Record
  updateOneSection(data: SectionUpdateInput!, where: SectionWhereUniqueInput!): Section
  updateOneSurvey(data: SurveyUpdateInput!, where: SurveyWhereUniqueInput!): Survey
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  crossTabRecordInfo(primaryElementIds: [String!]!, secondaryElementIds: [String!]!): [CrossTabRecordInfo]
  element(where: ElementWhereUniqueInput!): Element
  elements(after: ElementWhereUniqueInput, before: ElementWhereUniqueInput, first: Int, last: Int): [Element!]!
  question(where: QuestionWhereUniqueInput!): Question
  questions(after: QuestionWhereUniqueInput, before: QuestionWhereUniqueInput, first: Int, last: Int, orderBy: [QuestionOrderByInput!]): [Question!]!
  record(where: RecordWhereUniqueInput!): Record
  records(after: RecordWhereUniqueInput, before: RecordWhereUniqueInput, first: Int, last: Int): [Record!]!
  sections(after: SectionWhereUniqueInput, before: SectionWhereUniqueInput, first: Int, last: Int, orderBy: [SectionOrderByInput!]): [Section!]!
  surveys(after: SurveyWhereUniqueInput, before: SurveyWhereUniqueInput, first: Int, last: Int): [Survey!]!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Question {
  elements(after: ElementWhereUniqueInput, before: ElementWhereUniqueInput, first: Int, last: Int): [Element!]!
  embedding: [Float!]!
  id: String!
  name: String!
  qid: String!
  section: Section
  selector: String!
  tag: String!
  text: String!
  type: String!
}

input QuestionCreateembeddingInput {
  set: [Float!]
}

input QuestionCreateInput {
  categories: QuestionCreateManyWithoutQuestionInput
  elements: ElementCreateManyWithoutQuestionInput
  embedding: QuestionCreateembeddingInput
  id: String
  name: String!
  qid: String!
  question: QuestionCreateOneWithoutCategoriesInput
  section: SectionCreateOneWithoutQuestionsInput
  selector: String!
  subSelector: String
  tag: String!
  text: String!
  type: String!
}

input QuestionCreateManyWithoutQuestionInput {
  connect: [QuestionWhereUniqueInput!]
  connectOrCreate: [QuestionCreateOrConnectWithoutquestionInput!]
  create: [QuestionCreateWithoutQuestionInput!]
}

input QuestionCreateManyWithoutSectionInput {
  connect: [QuestionWhereUniqueInput!]
  connectOrCreate: [QuestionCreateOrConnectWithoutsectionInput!]
  create: [QuestionCreateWithoutSectionInput!]
}

input QuestionCreateOneWithoutCategoriesInput {
  connect: QuestionWhereUniqueInput
  connectOrCreate: QuestionCreateOrConnectWithoutcategoriesInput
  create: QuestionCreateWithoutCategoriesInput
}

input QuestionCreateOneWithoutElementsInput {
  connect: QuestionWhereUniqueInput
  connectOrCreate: QuestionCreateOrConnectWithoutelementsInput
  create: QuestionCreateWithoutElementsInput
}

input QuestionCreateOrConnectWithoutcategoriesInput {
  create: QuestionCreateWithoutCategoriesInput!
  where: QuestionWhereUniqueInput!
}

input QuestionCreateOrConnectWithoutelementsInput {
  create: QuestionCreateWithoutElementsInput!
  where: QuestionWhereUniqueInput!
}

input QuestionCreateOrConnectWithoutquestionInput {
  create: QuestionCreateWithoutQuestionInput!
  where: QuestionWhereUniqueInput!
}

input QuestionCreateOrConnectWithoutsectionInput {
  create: QuestionCreateWithoutSectionInput!
  where: QuestionWhereUniqueInput!
}

input QuestionCreateWithoutCategoriesInput {
  elements: ElementCreateManyWithoutQuestionInput
  embedding: QuestionCreateembeddingInput
  id: String
  name: String!
  qid: String!
  question: QuestionCreateOneWithoutCategoriesInput
  section: SectionCreateOneWithoutQuestionsInput
  selector: String!
  subSelector: String
  tag: String!
  text: String!
  type: String!
}

input QuestionCreateWithoutElementsInput {
  categories: QuestionCreateManyWithoutQuestionInput
  embedding: QuestionCreateembeddingInput
  id: String
  name: String!
  qid: String!
  question: QuestionCreateOneWithoutCategoriesInput
  section: SectionCreateOneWithoutQuestionsInput
  selector: String!
  subSelector: String
  tag: String!
  text: String!
  type: String!
}

input QuestionCreateWithoutQuestionInput {
  categories: QuestionCreateManyWithoutQuestionInput
  elements: ElementCreateManyWithoutQuestionInput
  embedding: QuestionCreateembeddingInput
  id: String
  name: String!
  qid: String!
  section: SectionCreateOneWithoutQuestionsInput
  selector: String!
  subSelector: String
  tag: String!
  text: String!
  type: String!
}

input QuestionCreateWithoutSectionInput {
  categories: QuestionCreateManyWithoutQuestionInput
  elements: ElementCreateManyWithoutQuestionInput
  embedding: QuestionCreateembeddingInput
  id: String
  name: String!
  qid: String!
  question: QuestionCreateOneWithoutCategoriesInput
  selector: String!
  subSelector: String
  tag: String!
  text: String!
  type: String!
}

input QuestionListRelationFilter {
  every: QuestionWhereInput
  none: QuestionWhereInput
  some: QuestionWhereInput
}

input QuestionOrderByInput {
  embedding: SortOrder
  id: SortOrder
  name: SortOrder
  qid: SortOrder
  questionId: SortOrder
  sectionId: SortOrder
  selector: SortOrder
  subSelector: SortOrder
  tag: SortOrder
  text: SortOrder
  type: SortOrder
}

input QuestionScalarWhereInput {
  AND: [QuestionScalarWhereInput!]
  embedding: FloatNullableListFilter
  id: StringFilter
  name: StringFilter
  NOT: [QuestionScalarWhereInput!]
  OR: [QuestionScalarWhereInput!]
  qid: StringFilter
  questionId: StringNullableFilter
  sectionId: StringNullableFilter
  selector: StringFilter
  subSelector: StringNullableFilter
  tag: StringFilter
  text: StringFilter
  type: StringFilter
}

input QuestionUpdateembeddingInput {
  set: [Float!]
}

input QuestionUpdateInput {
  categories: QuestionUpdateManyWithoutQuestionInput
  elements: ElementUpdateManyWithoutQuestionInput
  embedding: QuestionUpdateembeddingInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  qid: StringFieldUpdateOperationsInput
  question: QuestionUpdateOneWithoutCategoriesInput
  section: SectionUpdateOneWithoutQuestionsInput
  selector: StringFieldUpdateOperationsInput
  subSelector: NullableStringFieldUpdateOperationsInput
  tag: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input QuestionUpdateManyMutationInput {
  embedding: QuestionUpdateembeddingInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  qid: StringFieldUpdateOperationsInput
  selector: StringFieldUpdateOperationsInput
  subSelector: NullableStringFieldUpdateOperationsInput
  tag: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input QuestionUpdateManyWithoutQuestionInput {
  connect: [QuestionWhereUniqueInput!]
  connectOrCreate: [QuestionCreateOrConnectWithoutquestionInput!]
  create: [QuestionCreateWithoutQuestionInput!]
  delete: [QuestionWhereUniqueInput!]
  deleteMany: [QuestionScalarWhereInput!]
  disconnect: [QuestionWhereUniqueInput!]
  set: [QuestionWhereUniqueInput!]
  update: [QuestionUpdateWithWhereUniqueWithoutQuestionInput!]
  updateMany: [QuestionUpdateManyWithWhereWithoutQuestionInput!]
  upsert: [QuestionUpsertWithWhereUniqueWithoutQuestionInput!]
}

input QuestionUpdateManyWithoutSectionInput {
  connect: [QuestionWhereUniqueInput!]
  connectOrCreate: [QuestionCreateOrConnectWithoutsectionInput!]
  create: [QuestionCreateWithoutSectionInput!]
  delete: [QuestionWhereUniqueInput!]
  deleteMany: [QuestionScalarWhereInput!]
  disconnect: [QuestionWhereUniqueInput!]
  set: [QuestionWhereUniqueInput!]
  update: [QuestionUpdateWithWhereUniqueWithoutSectionInput!]
  updateMany: [QuestionUpdateManyWithWhereWithoutSectionInput!]
  upsert: [QuestionUpsertWithWhereUniqueWithoutSectionInput!]
}

input QuestionUpdateManyWithWhereWithoutQuestionInput {
  data: QuestionUpdateManyMutationInput!
  where: QuestionScalarWhereInput!
}

input QuestionUpdateManyWithWhereWithoutSectionInput {
  data: QuestionUpdateManyMutationInput!
  where: QuestionScalarWhereInput!
}

input QuestionUpdateOneWithoutCategoriesInput {
  connect: QuestionWhereUniqueInput
  connectOrCreate: QuestionCreateOrConnectWithoutcategoriesInput
  create: QuestionCreateWithoutCategoriesInput
  delete: Boolean
  disconnect: Boolean
  update: QuestionUpdateWithoutCategoriesInput
  upsert: QuestionUpsertWithoutCategoriesInput
}

input QuestionUpdateOneWithoutElementsInput {
  connect: QuestionWhereUniqueInput
  connectOrCreate: QuestionCreateOrConnectWithoutelementsInput
  create: QuestionCreateWithoutElementsInput
  delete: Boolean
  disconnect: Boolean
  update: QuestionUpdateWithoutElementsInput
  upsert: QuestionUpsertWithoutElementsInput
}

input QuestionUpdateWithoutCategoriesInput {
  elements: ElementUpdateManyWithoutQuestionInput
  embedding: QuestionUpdateembeddingInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  qid: StringFieldUpdateOperationsInput
  question: QuestionUpdateOneWithoutCategoriesInput
  section: SectionUpdateOneWithoutQuestionsInput
  selector: StringFieldUpdateOperationsInput
  subSelector: NullableStringFieldUpdateOperationsInput
  tag: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input QuestionUpdateWithoutElementsInput {
  categories: QuestionUpdateManyWithoutQuestionInput
  embedding: QuestionUpdateembeddingInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  qid: StringFieldUpdateOperationsInput
  question: QuestionUpdateOneWithoutCategoriesInput
  section: SectionUpdateOneWithoutQuestionsInput
  selector: StringFieldUpdateOperationsInput
  subSelector: NullableStringFieldUpdateOperationsInput
  tag: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input QuestionUpdateWithoutQuestionInput {
  categories: QuestionUpdateManyWithoutQuestionInput
  elements: ElementUpdateManyWithoutQuestionInput
  embedding: QuestionUpdateembeddingInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  qid: StringFieldUpdateOperationsInput
  section: SectionUpdateOneWithoutQuestionsInput
  selector: StringFieldUpdateOperationsInput
  subSelector: NullableStringFieldUpdateOperationsInput
  tag: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input QuestionUpdateWithoutSectionInput {
  categories: QuestionUpdateManyWithoutQuestionInput
  elements: ElementUpdateManyWithoutQuestionInput
  embedding: QuestionUpdateembeddingInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  qid: StringFieldUpdateOperationsInput
  question: QuestionUpdateOneWithoutCategoriesInput
  selector: StringFieldUpdateOperationsInput
  subSelector: NullableStringFieldUpdateOperationsInput
  tag: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input QuestionUpdateWithWhereUniqueWithoutQuestionInput {
  data: QuestionUpdateWithoutQuestionInput!
  where: QuestionWhereUniqueInput!
}

input QuestionUpdateWithWhereUniqueWithoutSectionInput {
  data: QuestionUpdateWithoutSectionInput!
  where: QuestionWhereUniqueInput!
}

input QuestionUpsertWithoutCategoriesInput {
  create: QuestionCreateWithoutCategoriesInput!
  update: QuestionUpdateWithoutCategoriesInput!
}

input QuestionUpsertWithoutElementsInput {
  create: QuestionCreateWithoutElementsInput!
  update: QuestionUpdateWithoutElementsInput!
}

input QuestionUpsertWithWhereUniqueWithoutQuestionInput {
  create: QuestionCreateWithoutQuestionInput!
  update: QuestionUpdateWithoutQuestionInput!
  where: QuestionWhereUniqueInput!
}

input QuestionUpsertWithWhereUniqueWithoutSectionInput {
  create: QuestionCreateWithoutSectionInput!
  update: QuestionUpdateWithoutSectionInput!
  where: QuestionWhereUniqueInput!
}

input QuestionWhereInput {
  AND: [QuestionWhereInput!]
  categories: QuestionListRelationFilter
  elements: ElementListRelationFilter
  embedding: FloatNullableListFilter
  id: StringFilter
  name: StringFilter
  NOT: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  qid: StringFilter
  question: QuestionWhereInput
  questionId: StringNullableFilter
  section: SectionWhereInput
  sectionId: StringNullableFilter
  selector: StringFilter
  subSelector: StringNullableFilter
  tag: StringFilter
  text: StringFilter
  type: StringFilter
}

input QuestionWhereUniqueInput {
  id: String
}

type Record {
  elements(after: ElementWhereUniqueInput, before: ElementWhereUniqueInput, first: Int, last: Int): [Element!]!
  id: String!
  meta: Json!
  user: User!
}

input RecordCreateInput {
  elements: ElementCreateManyWithoutRecordsInput
  id: String
  meta: Json!
  Survey: SurveyCreateOneWithoutRecordInput
  time: DateTime
  user: UserCreateOneWithoutRecordsInput!
}

input RecordCreateManyWithoutElementsInput {
  connect: [RecordWhereUniqueInput!]
  connectOrCreate: [RecordCreateOrConnectWithoutelementsInput!]
  create: [RecordCreateWithoutElementsInput!]
}

input RecordCreateManyWithoutSurveyInput {
  connect: [RecordWhereUniqueInput!]
  connectOrCreate: [RecordCreateOrConnectWithoutSurveyInput!]
  create: [RecordCreateWithoutSurveyInput!]
}

input RecordCreateManyWithoutUserInput {
  connect: [RecordWhereUniqueInput!]
  connectOrCreate: [RecordCreateOrConnectWithoutuserInput!]
  create: [RecordCreateWithoutUserInput!]
}

input RecordCreateOrConnectWithoutelementsInput {
  create: RecordCreateWithoutElementsInput!
  where: RecordWhereUniqueInput!
}

input RecordCreateOrConnectWithoutSurveyInput {
  create: RecordCreateWithoutSurveyInput!
  where: RecordWhereUniqueInput!
}

input RecordCreateOrConnectWithoutuserInput {
  create: RecordCreateWithoutUserInput!
  where: RecordWhereUniqueInput!
}

input RecordCreateWithoutElementsInput {
  id: String
  meta: Json!
  Survey: SurveyCreateOneWithoutRecordInput
  time: DateTime
  user: UserCreateOneWithoutRecordsInput!
}

input RecordCreateWithoutSurveyInput {
  elements: ElementCreateManyWithoutRecordsInput
  id: String
  meta: Json!
  time: DateTime
  user: UserCreateOneWithoutRecordsInput!
}

input RecordCreateWithoutUserInput {
  elements: ElementCreateManyWithoutRecordsInput
  id: String
  meta: Json!
  Survey: SurveyCreateOneWithoutRecordInput
  time: DateTime
}

input RecordListRelationFilter {
  every: RecordWhereInput
  none: RecordWhereInput
  some: RecordWhereInput
}

input RecordScalarWhereInput {
  AND: [RecordScalarWhereInput!]
  id: StringFilter
  NOT: [RecordScalarWhereInput!]
  OR: [RecordScalarWhereInput!]
  surveyId: StringNullableFilter
  time: DateTimeFilter
  userId: StringFilter
}

input RecordUpdateInput {
  elements: ElementUpdateManyWithoutRecordsInput
  id: StringFieldUpdateOperationsInput
  meta: Json
  Survey: SurveyUpdateOneWithoutRecordInput
  time: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutRecordsInput
}

input RecordUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  meta: Json
  time: DateTimeFieldUpdateOperationsInput
}

input RecordUpdateManyWithoutElementsInput {
  connect: [RecordWhereUniqueInput!]
  connectOrCreate: [RecordCreateOrConnectWithoutelementsInput!]
  create: [RecordCreateWithoutElementsInput!]
  delete: [RecordWhereUniqueInput!]
  deleteMany: [RecordScalarWhereInput!]
  disconnect: [RecordWhereUniqueInput!]
  set: [RecordWhereUniqueInput!]
  update: [RecordUpdateWithWhereUniqueWithoutElementsInput!]
  updateMany: [RecordUpdateManyWithWhereWithoutElementsInput!]
  upsert: [RecordUpsertWithWhereUniqueWithoutElementsInput!]
}

input RecordUpdateManyWithoutSurveyInput {
  connect: [RecordWhereUniqueInput!]
  connectOrCreate: [RecordCreateOrConnectWithoutSurveyInput!]
  create: [RecordCreateWithoutSurveyInput!]
  delete: [RecordWhereUniqueInput!]
  deleteMany: [RecordScalarWhereInput!]
  disconnect: [RecordWhereUniqueInput!]
  set: [RecordWhereUniqueInput!]
  update: [RecordUpdateWithWhereUniqueWithoutSurveyInput!]
  updateMany: [RecordUpdateManyWithWhereWithoutSurveyInput!]
  upsert: [RecordUpsertWithWhereUniqueWithoutSurveyInput!]
}

input RecordUpdateManyWithoutUserInput {
  connect: [RecordWhereUniqueInput!]
  connectOrCreate: [RecordCreateOrConnectWithoutuserInput!]
  create: [RecordCreateWithoutUserInput!]
  delete: [RecordWhereUniqueInput!]
  deleteMany: [RecordScalarWhereInput!]
  disconnect: [RecordWhereUniqueInput!]
  set: [RecordWhereUniqueInput!]
  update: [RecordUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [RecordUpdateManyWithWhereWithoutUserInput!]
  upsert: [RecordUpsertWithWhereUniqueWithoutUserInput!]
}

input RecordUpdateManyWithWhereWithoutElementsInput {
  data: RecordUpdateManyMutationInput!
  where: RecordScalarWhereInput!
}

input RecordUpdateManyWithWhereWithoutSurveyInput {
  data: RecordUpdateManyMutationInput!
  where: RecordScalarWhereInput!
}

input RecordUpdateManyWithWhereWithoutUserInput {
  data: RecordUpdateManyMutationInput!
  where: RecordScalarWhereInput!
}

input RecordUpdateWithoutElementsInput {
  id: StringFieldUpdateOperationsInput
  meta: Json
  Survey: SurveyUpdateOneWithoutRecordInput
  time: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutRecordsInput
}

input RecordUpdateWithoutSurveyInput {
  elements: ElementUpdateManyWithoutRecordsInput
  id: StringFieldUpdateOperationsInput
  meta: Json
  time: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutRecordsInput
}

input RecordUpdateWithoutUserInput {
  elements: ElementUpdateManyWithoutRecordsInput
  id: StringFieldUpdateOperationsInput
  meta: Json
  Survey: SurveyUpdateOneWithoutRecordInput
  time: DateTimeFieldUpdateOperationsInput
}

input RecordUpdateWithWhereUniqueWithoutElementsInput {
  data: RecordUpdateWithoutElementsInput!
  where: RecordWhereUniqueInput!
}

input RecordUpdateWithWhereUniqueWithoutSurveyInput {
  data: RecordUpdateWithoutSurveyInput!
  where: RecordWhereUniqueInput!
}

input RecordUpdateWithWhereUniqueWithoutUserInput {
  data: RecordUpdateWithoutUserInput!
  where: RecordWhereUniqueInput!
}

input RecordUpsertWithWhereUniqueWithoutElementsInput {
  create: RecordCreateWithoutElementsInput!
  update: RecordUpdateWithoutElementsInput!
  where: RecordWhereUniqueInput!
}

input RecordUpsertWithWhereUniqueWithoutSurveyInput {
  create: RecordCreateWithoutSurveyInput!
  update: RecordUpdateWithoutSurveyInput!
  where: RecordWhereUniqueInput!
}

input RecordUpsertWithWhereUniqueWithoutUserInput {
  create: RecordCreateWithoutUserInput!
  update: RecordUpdateWithoutUserInput!
  where: RecordWhereUniqueInput!
}

input RecordWhereInput {
  AND: [RecordWhereInput!]
  elements: ElementListRelationFilter
  id: StringFilter
  NOT: [RecordWhereInput!]
  OR: [RecordWhereInput!]
  Survey: SurveyWhereInput
  surveyId: StringNullableFilter
  time: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input RecordWhereUniqueInput {
  id: String
}

type Section {
  id: String!
  name: String!
  questions(after: QuestionWhereUniqueInput, before: QuestionWhereUniqueInput, first: Int, last: Int, orderBy: [QuestionOrderByInput!]): [Question!]!
}

input SectionCreateInput {
  id: String
  name: String!
  questions: QuestionCreateManyWithoutSectionInput
  survey: SurveyCreateOneWithoutSectionsInput!
}

input SectionCreateManyWithoutSurveyInput {
  connect: [SectionWhereUniqueInput!]
  connectOrCreate: [SectionCreateOrConnectWithoutsurveyInput!]
  create: [SectionCreateWithoutSurveyInput!]
}

input SectionCreateOneWithoutQuestionsInput {
  connect: SectionWhereUniqueInput
  connectOrCreate: SectionCreateOrConnectWithoutquestionsInput
  create: SectionCreateWithoutQuestionsInput
}

input SectionCreateOrConnectWithoutquestionsInput {
  create: SectionCreateWithoutQuestionsInput!
  where: SectionWhereUniqueInput!
}

input SectionCreateOrConnectWithoutsurveyInput {
  create: SectionCreateWithoutSurveyInput!
  where: SectionWhereUniqueInput!
}

input SectionCreateWithoutQuestionsInput {
  id: String
  name: String!
  survey: SurveyCreateOneWithoutSectionsInput!
}

input SectionCreateWithoutSurveyInput {
  id: String
  name: String!
  questions: QuestionCreateManyWithoutSectionInput
}

input SectionListRelationFilter {
  every: SectionWhereInput
  none: SectionWhereInput
  some: SectionWhereInput
}

input SectionOrderByInput {
  id: SortOrder
  name: SortOrder
  surveyId: SortOrder
}

input SectionScalarWhereInput {
  AND: [SectionScalarWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [SectionScalarWhereInput!]
  OR: [SectionScalarWhereInput!]
  surveyId: StringFilter
}

input SectionUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  questions: QuestionUpdateManyWithoutSectionInput
  survey: SurveyUpdateOneRequiredWithoutSectionsInput
}

input SectionUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input SectionUpdateManyWithoutSurveyInput {
  connect: [SectionWhereUniqueInput!]
  connectOrCreate: [SectionCreateOrConnectWithoutsurveyInput!]
  create: [SectionCreateWithoutSurveyInput!]
  delete: [SectionWhereUniqueInput!]
  deleteMany: [SectionScalarWhereInput!]
  disconnect: [SectionWhereUniqueInput!]
  set: [SectionWhereUniqueInput!]
  update: [SectionUpdateWithWhereUniqueWithoutSurveyInput!]
  updateMany: [SectionUpdateManyWithWhereWithoutSurveyInput!]
  upsert: [SectionUpsertWithWhereUniqueWithoutSurveyInput!]
}

input SectionUpdateManyWithWhereWithoutSurveyInput {
  data: SectionUpdateManyMutationInput!
  where: SectionScalarWhereInput!
}

input SectionUpdateOneWithoutQuestionsInput {
  connect: SectionWhereUniqueInput
  connectOrCreate: SectionCreateOrConnectWithoutquestionsInput
  create: SectionCreateWithoutQuestionsInput
  delete: Boolean
  disconnect: Boolean
  update: SectionUpdateWithoutQuestionsInput
  upsert: SectionUpsertWithoutQuestionsInput
}

input SectionUpdateWithoutQuestionsInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  survey: SurveyUpdateOneRequiredWithoutSectionsInput
}

input SectionUpdateWithoutSurveyInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  questions: QuestionUpdateManyWithoutSectionInput
}

input SectionUpdateWithWhereUniqueWithoutSurveyInput {
  data: SectionUpdateWithoutSurveyInput!
  where: SectionWhereUniqueInput!
}

input SectionUpsertWithoutQuestionsInput {
  create: SectionCreateWithoutQuestionsInput!
  update: SectionUpdateWithoutQuestionsInput!
}

input SectionUpsertWithWhereUniqueWithoutSurveyInput {
  create: SectionCreateWithoutSurveyInput!
  update: SectionUpdateWithoutSurveyInput!
  where: SectionWhereUniqueInput!
}

input SectionWhereInput {
  AND: [SectionWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [SectionWhereInput!]
  OR: [SectionWhereInput!]
  questions: QuestionListRelationFilter
  survey: SurveyWhereInput
  surveyId: StringFilter
}

input SectionWhereUniqueInput {
  id: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Survey {
  id: String!
  name: String!
  sections(after: SectionWhereUniqueInput, before: SectionWhereUniqueInput, first: Int, last: Int): [Section!]!
}

input SurveyCreateInput {
  id: String
  name: String!
  Record: RecordCreateManyWithoutSurveyInput
  sections: SectionCreateManyWithoutSurveyInput
}

input SurveyCreateOneWithoutRecordInput {
  connect: SurveyWhereUniqueInput
  connectOrCreate: SurveyCreateOrConnectWithoutRecordInput
  create: SurveyCreateWithoutRecordInput
}

input SurveyCreateOneWithoutSectionsInput {
  connect: SurveyWhereUniqueInput
  connectOrCreate: SurveyCreateOrConnectWithoutsectionsInput
  create: SurveyCreateWithoutSectionsInput
}

input SurveyCreateOrConnectWithoutRecordInput {
  create: SurveyCreateWithoutRecordInput!
  where: SurveyWhereUniqueInput!
}

input SurveyCreateOrConnectWithoutsectionsInput {
  create: SurveyCreateWithoutSectionsInput!
  where: SurveyWhereUniqueInput!
}

input SurveyCreateWithoutRecordInput {
  id: String
  name: String!
  sections: SectionCreateManyWithoutSurveyInput
}

input SurveyCreateWithoutSectionsInput {
  id: String
  name: String!
  Record: RecordCreateManyWithoutSurveyInput
}

input SurveyUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  Record: RecordUpdateManyWithoutSurveyInput
  sections: SectionUpdateManyWithoutSurveyInput
}

input SurveyUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input SurveyUpdateOneRequiredWithoutSectionsInput {
  connect: SurveyWhereUniqueInput
  connectOrCreate: SurveyCreateOrConnectWithoutsectionsInput
  create: SurveyCreateWithoutSectionsInput
  update: SurveyUpdateWithoutSectionsInput
  upsert: SurveyUpsertWithoutSectionsInput
}

input SurveyUpdateOneWithoutRecordInput {
  connect: SurveyWhereUniqueInput
  connectOrCreate: SurveyCreateOrConnectWithoutRecordInput
  create: SurveyCreateWithoutRecordInput
  delete: Boolean
  disconnect: Boolean
  update: SurveyUpdateWithoutRecordInput
  upsert: SurveyUpsertWithoutRecordInput
}

input SurveyUpdateWithoutRecordInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  sections: SectionUpdateManyWithoutSurveyInput
}

input SurveyUpdateWithoutSectionsInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  Record: RecordUpdateManyWithoutSurveyInput
}

input SurveyUpsertWithoutRecordInput {
  create: SurveyCreateWithoutRecordInput!
  update: SurveyUpdateWithoutRecordInput!
}

input SurveyUpsertWithoutSectionsInput {
  create: SurveyCreateWithoutSectionsInput!
  update: SurveyUpdateWithoutSectionsInput!
}

input SurveyWhereInput {
  AND: [SurveyWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [SurveyWhereInput!]
  OR: [SurveyWhereInput!]
  Record: RecordListRelationFilter
  sections: SectionListRelationFilter
}

input SurveyWhereUniqueInput {
  id: String
}

type User {
  id: String!
  records(after: RecordWhereUniqueInput, before: RecordWhereUniqueInput, first: Int, last: Int): [Record!]!
}

input UserCreateInput {
  id: String
  records: RecordCreateManyWithoutUserInput
}

input UserCreateOneWithoutRecordsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutrecordsInput
  create: UserCreateWithoutRecordsInput
}

input UserCreateOrConnectWithoutrecordsInput {
  create: UserCreateWithoutRecordsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutRecordsInput {
  id: String
}

input UserUpdateInput {
  id: StringFieldUpdateOperationsInput
  records: RecordUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutRecordsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutrecordsInput
  create: UserCreateWithoutRecordsInput
  update: UserUpdateWithoutRecordsInput
  upsert: UserUpsertWithoutRecordsInput
}

input UserUpdateWithoutRecordsInput {
  id: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutRecordsInput {
  create: UserCreateWithoutRecordsInput!
  update: UserUpdateWithoutRecordsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  id: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  records: RecordListRelationFilter
}

input UserWhereUniqueInput {
  id: String
}
